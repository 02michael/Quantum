<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neural Network</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@200;300;400;500;600&display=swap" rel="stylesheet">
<style>
:root {
    --glass-bg: rgba(255, 255, 255, 0.03);
    --glass-border: rgba(255, 255, 255, 0.08);
    --glass-highlight: rgba(255, 255, 255, 0.2);
    --neon-accent: #667eea;
    --text-main: rgba(255, 255, 255, 0.9);
    --text-muted: rgba(255, 255, 255, 0.6);
}
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    user-select: none;
    -webkit-user-select: none;
}
body {
    overflow: hidden;
    background: #050508;
    font-family: 'Outfit', sans-serif;
    color: var(--text-main);
}
canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: crosshair;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
}
.glass-panel {
    backdrop-filter: blur(24px) saturate(120%);
    -webkit-backdrop-filter: blur(24px) saturate(120%);
    background: linear-gradient(
        145deg,
        rgba(255, 255, 255, 0.05) 0%,
        rgba(255, 255, 255, 0.01) 100%
    );
    border: 1px solid var(--glass-border);
    border-top: 1px solid var(--glass-highlight);
    border-left: 1px solid var(--glass-highlight);
    box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.4),
        inset 0 0 20px rgba(255, 255, 255, 0.02);
    border-radius: 24px;
    color: var(--text-main);
    transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
    position: absolute;
    z-index: 10;
    overflow: hidden;
}
.glass-panel::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.05),
        transparent
    );
    transform: skewX(-15deg);
    transition: 0.5s;
    pointer-events: none;
}
.glass-panel:hover {
    background: linear-gradient(
        145deg,
        rgba(255, 255, 255, 0.08) 0%,
        rgba(255, 255, 255, 0.02) 100%
    );
    box-shadow:
        0 30px 60px rgba(0, 0, 0, 0.5),
        inset 0 0 20px rgba(255, 255, 255, 0.05);
    transform: translateY(-2px);
    border-color: rgba(255, 255, 255, 0.15);
}
.glass-panel:hover::before {
    left: 150%;
    transition: 0.7s ease-in-out;
}
#instructions-container {
    top: 32px;
    left: 32px;
    width: 280px;
    padding: 24px;
}
#instruction-title {
    font-weight: 500;
    font-size: 18px;
    margin-bottom: 8px;
    letter-spacing: -0.02em;
    background: linear-gradient(135deg, #fff 30%, #a5b4fc 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 10px 20px rgba(0,0,0,0.2);
}
.instruction-text {
    font-size: 14px;
    line-height: 1.5;
    color: var(--text-muted);
    font-weight: 300;
}
#theme-selector {
    top: 32px;
    right: 32px;
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    width: 220px;
}
#theme-selector-title {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-muted);
    font-weight: 600;
    margin-bottom: 4px;
}
.theme-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
    justify-items: center;
}
.theme-button {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    position: relative;
    transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    box-shadow:
        0 4px 10px rgba(0,0,0,0.3),
        inset 0 2px 4px rgba(255,255,255,0.4),
        inset 0 -2px 4px rgba(0,0,0,0.2);
}
#theme-1 { background: radial-gradient(circle at 30% 30%, #a78bfa, #4c1d95); }
#theme-2 { background: radial-gradient(circle at 30% 30%, #fb7185, #9f1239); }
#theme-3 { background: radial-gradient(circle at 30% 30%, #38bdf8, #0c4a6e); }
.theme-button::after {
    content: '';
    position: absolute;
    top: -4px;
    left: -4px;
    right: -4px;
    bottom: -4px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.8);
    opacity: 0;
    transform: scale(1.1);
    transition: all 0.3s ease;
}
.theme-button:hover {
    transform: scale(1.15) translateY(-2px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.4), inset 0 2px 6px rgba(255,255,255,0.6);
}
.theme-button.active::after {
    opacity: 1;
    transform: scale(1);
    border-color: rgba(255,255,255,0.9);
    box-shadow: 0 0 15px rgba(255,255,255,0.3);
}
#density-controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 8px;
}
.density-label {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    color: var(--text-muted);
    font-weight: 300;
}
#density-value {
    color: white;
    font-weight: 500;
    text-shadow: 0 0 10px rgba(255,255,255,0.3);
}
.density-slider {
    -webkit-appearance: none;
    width: 100%;
    height: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    outline: none;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
}
.density-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #fff;
    cursor: pointer;
    box-shadow:
        0 0 15px rgba(255,255,255,0.8),
        0 2px 5px rgba(0,0,0,0.3);
    transition: all 0.2s ease;
    margin-top: -6px;
    position: relative;
    z-index: 2;
}
.density-slider::-webkit-slider-runnable-track {
    width: 100%;
    height: 6px;
    cursor: pointer;
    background: linear-gradient(90deg, rgba(255,255,255,0.3) var(--val, 100%), rgba(255,255,255,0.05) var(--val, 100%));
    border-radius: 3px;
}
.density-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 0 20px rgba(255,255,255,1);
}
#control-buttons {
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 16px;
    z-index: 20;
    padding: 8px;
    background: rgba(0,0,0,0.1);
}
.control-button {
    backdrop-filter: blur(20px) saturate(140%);
    -webkit-backdrop-filter: blur(20px) saturate(140%);
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-top: 1px solid rgba(255, 255, 255, 0.25);
    color: var(--text-main);
    padding: 12px 24px;
    border-radius: 50px;
    cursor: pointer;
    font-family: 'Outfit', sans-serif;
    font-size: 13px;
    font-weight: 500;
    letter-spacing: 0.5px;
    text-transform: uppercase;
    transition: all 0.3s ease;
    box-shadow:
        0 8px 20px rgba(0, 0, 0, 0.3),
        inset 0 0 10px rgba(255,255,255,0.02);
    overflow: hidden;
    position: relative;
    min-width: 100px;
    text-align: center;
}
.control-button:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.4);
    transform: translateY(-4px);
    box-shadow:
        0 15px 30px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(255, 255, 255, 0.1);
    text-shadow: 0 0 8px rgba(255,255,255,0.6);
}
.control-button:active {
    transform: translateY(-1px);
}
.control-button span {
    position: relative;
    z-index: 2;
}
@media (max-width: 640px) {
    #instructions-container {
        top: 16px;
        left: 16px;
        right: 16px;
        width: auto;
        padding: 16px;
        background: rgba(10, 10, 15, 0.6);
    }
    #theme-selector {
        top: auto;
        bottom: 100px;
        left: 16px;
        right: 16px;
        width: auto;
        padding: 16px;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
    }
    .theme-grid {
        margin-top: 0;
    }
    #control-buttons {
        bottom: 24px;
        width: 100%;
        justify-content: center;
        gap: 8px;
        padding: 0 16px;
    }
    .control-button {
        padding: 10px 16px;
        min-width: auto;
        font-size: 11px;
        flex: 1;
    }
}
</style>
<div id="instructions-container" class="glass-panel">
    <div id="instruction-title">Quantum Neural Network</div>
    <div class="instruction-text">Click to send energy pulses. <br>Drag to explore the structure.</div>
</div>
<div id="theme-selector" class="glass-panel">
    <div style="flex: 1;">
        <div id="theme-selector-title">Crystal Theme</div>
        <div class="theme-grid">
            <button class="theme-button active" id="theme-1" data-theme="0" aria-label="Purple Nebula"></button>
            <button class="theme-button" id="theme-2" data-theme="1" aria-label="Sunset Fire"></button>
            <button class="theme-button" id="theme-3" data-theme="2" aria-label="Ocean Aurora"></button>
        </div>
    </div>
    <div id="density-controls" style="flex: 1;">
        <div class="density-label"><span>Density</span><span id="density-value">100%</span></div>
        <input type="range" min="30" max="100" value="100" class="density-slider" id="density-slider"
            aria-label="Network Density" oninput="this.style.setProperty('--val', this.value + '%')">
    </div>
</div>
<div id="control-buttons">
    <button id="change-formation-btn" class="control-button"><span>Morph</span></button>
    <button id="pause-play-btn" class="control-button"><span>Freeze</span></button>
    <button id="reset-camera-btn" class="control-button"><span>Reset</span></button>
</div>
<canvas id="neural-network-canvas"></canvas>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
    }
}
</script>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
    const config = {
        paused: false,
        activePaletteIndex: 0,
        currentFormation: 0,
        numFormations: 3,
        densityFactor: 1
    };
    const colorPalettes = [
        [
            new THREE.Color(0x667eea),
            new THREE.Color(0x764ba2),
            new THREE.Color(0xf093fb),
            new THREE.Color(0x9d50bb),
            new THREE.Color(0x6e48aa)
        ],
        [
            new THREE.Color(0xf857a6),
            new THREE.Color(0xff5858),
            new THREE.Color(0xfeca57),
            new THREE.Color(0xff6348),
            new THREE.Color(0xff9068)
        ],
        [
            new THREE.Color(0x4facfe),
            new THREE.Color(0x00f2fe),
            new THREE.Color(0x43e97b),
            new THREE.Color(0x38f9d7),
            new THREE.Color(0x4484ce)
        ]
    ];
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002);
    const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 8, 28);
    const canvasElement = document.getElementById('neural-network-canvas');
    const renderer = new THREE.WebGLRenderer({
        canvas: canvasElement,
        antialias: true,
        powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    function createStarfield() {
        const count = 8000;
        const positions = [];
        const colors = [];
        const sizes = [];
        for (let i = 0; i < count; i++) {
            const r = THREE.MathUtils.randFloat(50, 150);
            const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
            const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
            positions.push(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
            const colorChoice = Math.random();
            if (colorChoice < 0.7) {
                colors.push(1, 1, 1);
            } else if (colorChoice < 0.85) {
                colors.push(0.7, 0.8, 1);
            } else {
                colors.push(1, 0.9, 0.8);
            }
            sizes.push(THREE.MathUtils.randFloat(0.1, 0.3));
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
        const mat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 }
            },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                uniform float uTime;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    float twinkle = sin(uTime * 2.0 + position.x * 100.0) * 0.3 + 0.7;
                    gl_PointSize = size * twinkle * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                void main() {
                    vec2 center = gl_PointCoord - 0.5;
                    float dist = length(center);
                    if (dist > 0.5) discard;
                    float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                    gl_FragColor = vec4(vColor, alpha * 0.8);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        return new THREE.Points(geo, mat);
    }
    const starField = createStarfield();
    scene.add(starField);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
        controls.dampingFactor = 0.05;
    controls.rotateSpeed = 0.6;
    controls.minDistance = 8;
    controls.maxDistance = 80;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.2;
    controls.enablePan = false;
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.8,
        0.6,
        0.7
    );
    composer.addPass(bloomPass);
    composer.addPass(new OutputPass());
    const pulseUniforms = {
        uTime: { value: 0.0 },
        uPulsePositions: { value: [
            new THREE.Vector3(1e3, 1e3, 1e3),
            new THREE.Vector3(1e3, 1e3, 1e3),
            new THREE.Vector3(1e3, 1e3, 1e3)
        ]},
        uPulseTimes: { value: [-1e3, -1e3, -1e3] },
        uPulseColors: { value: [
            new THREE.Color(1, 1, 1),
            new THREE.Color(1, 1, 1),
            new THREE.Color(1, 1, 1)
        ]},
        uPulseSpeed: { value: 18.0 },
        uBaseNodeSize: { value: 0.6 }
    };
    const noiseFunctions = `
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
    
    float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
        
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);
        
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);
        
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        
        i = mod289(i);
        vec4 p = permute(permute(permute(
            i.z + vec4(0.0, i1.z, i2.z, 1.0))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            
        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;
        
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);
        
        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        
        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);
        
        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        
        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
        
        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);
        
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;
        
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m * m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
    }`;
    const nodeShader = {
        vertexShader: `${noiseFunctions}
        attribute float nodeSize;
        attribute float nodeType;
        attribute vec3 nodeColor;
        attribute float distanceFromRoot;
        
        uniform float uTime;
        uniform vec3 uPulsePositions[3];
        uniform float uPulseTimes[3];
        uniform float uPulseSpeed;
        uniform float uBaseNodeSize;
        
        varying vec3 vColor;
        varying float vNodeType;
        varying vec3 vPosition;
        varying float vPulseIntensity;
        varying float vDistanceFromRoot;
        varying float vGlow;
        float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {
            if (pulseTime < 0.0) return 0.0;
            float timeSinceClick = uTime - pulseTime;
            if (timeSinceClick < 0.0 || timeSinceClick > 4.0) return 0.0;
            float pulseRadius = timeSinceClick * uPulseSpeed;
            float distToClick = distance(worldPos, pulsePos);
            float pulseThickness = 3.0;
            float waveProximity = abs(distToClick - pulseRadius);
            return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(4.0, 0.0, timeSinceClick);
        }
        void main() {
            vNodeType = nodeType;
            vColor = nodeColor;
            vDistanceFromRoot = distanceFromRoot;
            vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vPosition = worldPos;
            float totalPulseIntensity = 0.0;
            for (int i = 0; i < 3; i++) {
                totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
            }
            vPulseIntensity = min(totalPulseIntensity, 1.0);
            float breathe = sin(uTime * 0.7 + distanceFromRoot * 0.15) * 0.15 + 0.85;
            float baseSize = nodeSize * breathe;
            float pulseSize = baseSize * (1.0 + vPulseIntensity * 2.5);
            vGlow = 0.5 + 0.5 * sin(uTime * 0.5 + distanceFromRoot * 0.2);
            vec3 modifiedPosition = position;
            if (nodeType > 0.5) {
                float noise = snoise(position * 0.08 + uTime * 0.08);
                modifiedPosition += normal * noise * 0.15;
            }
            vec4 mvPosition = modelViewMatrix * vec4(modifiedPosition, 1.0);
            gl_PointSize = pulseSize * uBaseNodeSize * (1000.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }`,
        fragmentShader: `
        uniform float uTime;
        uniform vec3 uPulseColors[3];
        
        varying vec3 vColor;
        varying float vNodeType;
        varying vec3 vPosition;
        varying float vPulseIntensity;
        varying float vDistanceFromRoot;
        varying float vGlow;
        void main() {
            vec2 center = 2.0 * gl_PointCoord - 1.0;
            float dist = length(center);
            if (dist > 1.0) discard;
            float glow1 = 1.0 - smoothstep(0.0, 0.5, dist);
            float glow2 = 1.0 - smoothstep(0.0, 1.0, dist);
            float glowStrength = pow(glow1, 1.2) + glow2 * 0.3;
            float breatheColor = 0.9 + 0.1 * sin(uTime * 0.6 + vDistanceFromRoot * 0.25);
            vec3 baseColor = vColor * breatheColor;
            vec3 finalColor = baseColor;
            if (vPulseIntensity > 0.0) {
                vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.4);
                finalColor = mix(baseColor, pulseColor, vPulseIntensity * 0.8);
                finalColor *= (1.0 + vPulseIntensity * 1.2);
                glowStrength *= (1.0 + vPulseIntensity);
            }
            float coreBrightness = smoothstep(0.4, 0.0, dist);
            finalColor += vec3(1.0) * coreBrightness * 0.3;
            float alpha = glowStrength * (0.95 - 0.3 * dist);
            float camDistance = length(vPosition - cameraPosition);
            float distanceFade = smoothstep(100.0, 15.0, camDistance);
            if (vNodeType > 0.5) {
                finalColor *= 1.1;
                alpha *= 0.9;
            }
            finalColor *= (1.0 + vGlow * 0.1);
            gl_FragColor = vec4(finalColor, alpha * distanceFade);
        }`
    };
    const connectionShader = {
        vertexShader: `${noiseFunctions}
        attribute vec3 startPoint;
        attribute vec3 endPoint;
        attribute float connectionStrength;
        attribute float pathIndex;
        attribute vec3 connectionColor;
        
        uniform float uTime;
        uniform vec3 uPulsePositions[3];
        uniform float uPulseTimes[3];
        uniform float uPulseSpeed;
        
        varying vec3 vColor;
        varying float vConnectionStrength;
        varying float vPulseIntensity;
        varying float vPathPosition;
        varying float vDistanceFromCamera;
        float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {
            if (pulseTime < 0.0) return 0.0;
            float timeSinceClick = uTime - pulseTime;
            if (timeSinceClick < 0.0 || timeSinceClick > 4.0) return 0.0;
            
            float pulseRadius = timeSinceClick * uPulseSpeed;
            float distToClick = distance(worldPos, pulsePos);
            float pulseThickness = 3.0;
            float waveProximity = abs(distToClick - pulseRadius);
            
            return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(4.0, 0.0, timeSinceClick);
        }
        void main() {
            float t = position.x;
            vPathPosition = t;
            vec3 midPoint = mix(startPoint, endPoint, 0.5);
            float pathOffset = sin(t * 3.14159) * 0.15;
            vec3 perpendicular = normalize(cross(normalize(endPoint - startPoint), vec3(0.0, 1.0, 0.0)));
            if (length(perpendicular) < 0.1) perpendicular = vec3(1.0, 0.0, 0.0);
            midPoint += perpendicular * pathOffset;
            vec3 p0 = mix(startPoint, midPoint, t);
            vec3 p1 = mix(midPoint, endPoint, t);
            vec3 finalPos = mix(p0, p1, t);
            float noiseTime = uTime * 0.15;
            float noise = snoise(vec3(pathIndex * 0.08, t * 0.6, noiseTime));
            finalPos += perpendicular * noise * 0.12;
            vec3 worldPos = (modelMatrix * vec4(finalPos, 1.0)).xyz;
            float totalPulseIntensity = 0.0;
            for (int i = 0; i < 3; i++) {
                totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
            }
            vPulseIntensity = min(totalPulseIntensity, 1.0);
            vColor = connectionColor;
            vConnectionStrength = connectionStrength;
            
            vDistanceFromCamera = length(worldPos - cameraPosition);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
        }`,
        fragmentShader: `
        uniform float uTime;
        uniform vec3 uPulseColors[3];
        
        varying vec3 vColor;
        varying float vConnectionStrength;
        varying float vPulseIntensity;
        varying float vPathPosition;
        varying float vDistanceFromCamera;
        void main() {
            float flowPattern1 = sin(vPathPosition * 25.0 - uTime * 4.0) * 0.5 + 0.5;
            float flowPattern2 = sin(vPathPosition * 15.0 - uTime * 2.5 + 1.57) * 0.5 + 0.5;
            float combinedFlow = (flowPattern1 + flowPattern2 * 0.5) / 1.5;
            
            vec3 baseColor = vColor * (0.8 + 0.2 * sin(uTime * 0.6 + vPathPosition * 12.0));
            float flowIntensity = 0.4 * combinedFlow * vConnectionStrength;
            vec3 finalColor = baseColor;
            if (vPulseIntensity > 0.0) {
                vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.3);
                finalColor = mix(baseColor, pulseColor * 1.2, vPulseIntensity * 0.7);
                flowIntensity += vPulseIntensity * 0.8;
            }
            finalColor *= (0.7 + flowIntensity + vConnectionStrength * 0.5);
            float baseAlpha = 0.7 * vConnectionStrength;
            float flowAlpha = combinedFlow * 0.3;
            float alpha = baseAlpha + flowAlpha;
            alpha = mix(alpha, min(1.0, alpha * 2.5), vPulseIntensity);
            float distanceFade = smoothstep(100.0, 15.0, vDistanceFromCamera);
            gl_FragColor = vec4(finalColor, alpha * distanceFade);
        }`
    };